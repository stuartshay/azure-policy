name: Deploy Azure Function

on:
  push:
    branches: [master]
    paths:
      - 'functions/basic/**'
      - '.github/workflows/deploy-function.yml'
  pull_request:
    branches: [master]
    paths:
      - 'functions/basic/**'
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_NAME: func-azpolicy-dev-001
  AZURE_FUNCTIONAPP_PACKAGE_PATH: './functions/basic'
  PYTHON_VERSION: '3.13'

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    name: Build and Test Function

    steps:
      - name: 'Checkout GitHub Action'
        uses: actions/checkout@v4

      - name: Setup Python ${{ env.PYTHON_VERSION }} Environment
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: 'Resolve Project Dependencies Using Pip'
        shell: bash
        run: |
          pushd '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          python -m pip install --upgrade pip
          pip install -r requirements.txt --target=".python_packages/lib/site-packages"
          popd

      - name: 'Run Unit Tests'
        shell: bash
        run: |
          pushd '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          python -m pip install pytest pytest-cov
          # Install the function requirements for testing
          python -m pip install -r requirements.txt
          python -m pytest tests/ -v --cov=. --cov-report=xml
          popd

      - name: 'Create Function Package'
        shell: bash
        run: |
          pushd '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          # Remove test files and cache from package
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
          find . -name "*.pyc" -delete 2>/dev/null || true
          find . -name ".coverage" -delete 2>/dev/null || true
          find . -name "coverage.xml" -delete 2>/dev/null || true
          popd

      - name: 'Upload Function Package'
        uses: actions/upload-artifact@v4
        with:
          name: function-package
          path: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          retention-days: 1

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-test
    name: Deploy to Azure Function App
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch') && github.event_name != 'pull_request'

    steps:
      - name: 'Download Function Package'
        uses: actions/download-artifact@v4
        with:
          name: function-package
          path: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}

      - name: 'Azure Login'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Verify Infrastructure'
        shell: bash
        run: |
          echo "=== Infrastructure Verification ==="

          # Check if resource group exists
          echo "üìã Checking resource group..."
          RG_EXISTS=$(az group exists --name rg-azpolicy-dev-eastus)
          echo "Resource Group exists: $RG_EXISTS"

          if [ "$RG_EXISTS" = "false" ]; then
            echo "‚ùå ERROR: Resource group 'rg-azpolicy-dev-eastus' does not exist!"
            exit 1
          fi

          # Check Function App existence and status
          echo "üì± Checking Function App..."
          FUNC_APP_STATE=$(az functionapp show \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "{name:name, state:state, publicNetworkAccess:publicNetworkAccessEnabled, httpsOnly:httpsOnly}" \
            -o json 2>/dev/null || echo "null")

          if [ "$FUNC_APP_STATE" = "null" ]; then
            echo "‚ùå ERROR: Function App '${{ env.AZURE_FUNCTIONAPP_NAME }}' does not exist!"
            exit 1
          fi

          echo "Function App Details:"
          echo "$FUNC_APP_STATE" | jq .

          # Check Storage Account
          echo "üíæ Checking Storage Account..."
          STORAGE_STATE=$(az storage account show \
            --resource-group rg-azpolicy-dev-eastus \
            --name stfuncazpolicydev001 \
            --query "{name:name, provisioningState:provisioningState, publicNetworkAccess:publicNetworkAccess}" \
            -o json 2>/dev/null || echo "null")

          if [ "$STORAGE_STATE" = "null" ]; then
            echo "‚ùå ERROR: Storage Account 'stfuncazpolicydev001' does not exist!"
            exit 1
          fi

          echo "Storage Account Details:"
          echo "$STORAGE_STATE" | jq .

          # Check VNet Integration
          echo "üåê Checking VNet Integration..."
          VNET_CONFIG=$(az functionapp vnet-integration show \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "{vnetResourceId:vnetResourceId, subnetResourceId:subnetResourceId}" \
            -o json 2>/dev/null || echo "null")

          echo "VNet Integration:"
          if [ "$VNET_CONFIG" = "null" ]; then
            echo "No VNet integration configured"
          else
            echo "$VNET_CONFIG" | jq .
          fi

          # Check current access restrictions
          echo "üîí Checking Access Restrictions..."
          ACCESS_RESTRICTIONS=$(az functionapp config access-restriction show \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "ipSecurityRestrictions[?action=='Allow']" \
            -o json 2>/dev/null || echo "[]")

          echo "Current Access Restrictions:"
          echo "$ACCESS_RESTRICTIONS" | jq .

          # Check SCM site accessibility
          echo "üîß Testing SCM Site Connectivity..."
          SCM_URL="https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$SCM_URL" --max-time 10 || echo "000")
          echo "SCM Site HTTP Status: $HTTP_STATUS"

          if [ "$HTTP_STATUS" = "000" ]; then
            echo "‚ö†Ô∏è  WARNING: Cannot reach SCM site - likely network restrictions"
          elif [ "$HTTP_STATUS" = "403" ]; then
            echo "‚ö†Ô∏è  WARNING: SCM site blocked (403) - access restrictions active"
          elif [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "401" ]; then
            echo "‚úÖ SCM site is reachable"
          fi

          echo "=== Infrastructure Verification Complete ==="

      - name: 'Get Runner IP and Configure Access'
        shell: bash
        run: |
          # Get the current runner's public IP
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "Runner IP: $RUNNER_IP"

          # Check if Function App has public network access disabled
          PUBLIC_ACCESS=$(az functionapp show \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "publicNetworkAccessEnabled" -o tsv)

          echo "Public Network Access Enabled: $PUBLIC_ACCESS"

          if [ "$PUBLIC_ACCESS" = "false" ]; then
            echo "‚ö†Ô∏è  Function App has public network access disabled"
            echo "This may prevent GitHub Actions from deploying successfully"

            # Try to temporarily enable public access for deployment
            echo "Attempting to temporarily enable public network access..."
            az functionapp update \
              --resource-group rg-azpolicy-dev-eastus \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --set publicNetworkAccessEnabled=true || echo "Failed to enable public access"

            sleep 10
          fi

          # Add GitHub Actions IP range to Function App access restrictions
          echo "Adding runner IP to Function App access restrictions..."
          az functionapp config access-restriction add \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --rule-name "GitHubActions-$(date +%s)" \
            --action Allow \
            --ip-address "$RUNNER_IP/32" \
            --priority 100 || echo "Failed to add access restriction - may already exist or be blocked by VNet"

          echo "Waiting for access rule to take effect..."
          sleep 30

          # Test connectivity to SCM endpoint after configuration
          echo "Testing SCM connectivity after configuration..."
          SCM_URL="https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$SCM_URL" --max-time 15 || echo "000")
          echo "SCM Site HTTP Status after configuration: $HTTP_STATUS"

      - name: 'Deploy to Azure Functions'
        shell: bash
        run: |
          echo "Deploying function package using Azure CLI..."
          cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}

          # Create zip package
          zip -r ../function-deploy.zip . -x "tests/*" "*/__pycache__/*" "*.pyc" ".coverage" "coverage.xml"

          # Deploy using Azure CLI
          az functionapp deployment source config-zip \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --src ../function-deploy.zip \
            --build-remote true

          echo "Deployment completed"

      - name: 'Verify Deployment'
        shell: bash
        run: |
          echo "Waiting for deployment to complete and verifying deployment..."
          MAX_ATTEMPTS=10
          SLEEP_SECONDS=10
          ATTEMPT=1
          SUCCESS=0

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT: Checking function status..."
            # Try to show the HealthCheck function using Azure CLI
            FUNC_NAME=$(az functionapp function show \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --resource-group rg-azpolicy-dev-eastus \
              --function-name HealthCheck \
              --query "name" -o tsv 2>/dev/null)
            if [ "$FUNC_NAME" = "HealthCheck" ]; then
              echo "‚úÖ Function deployment verified successfully"
              SUCCESS=1
              break
            else
              echo "Function not available yet. Waiting $SLEEP_SECONDS seconds before retrying..."
              sleep $SLEEP_SECONDS
              ATTEMPT=$((ATTEMPT+1))
            fi
          done

          if [ $SUCCESS -ne 1 ]; then
            echo "‚ùå Function deployment verification failed after $MAX_ATTEMPTS attempts."
            exit 1
          fi

      - name: 'Cleanup Access Rules'
        if: always()
        shell: bash
        run: |
          echo "Cleaning up temporary GitHub Actions access rules..."

          # Remove any GitHub Actions rules (cleanup old ones too)
          az functionapp config access-restriction list \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "[?contains(name, 'GitHubActions')].name" -o tsv 2>/dev/null | \
          while read -r rule_name; do
            if [ -n "$rule_name" ]; then
              echo "Removing rule: $rule_name"
              az functionapp config access-restriction remove \
                --resource-group rg-azpolicy-dev-eastus \
                --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
                --rule-name "$rule_name" || true
            fi
          done

          # Restore original public network access setting if it was disabled
          echo "Checking if public network access should be restored..."

          # If VNet integration exists, we should disable public access for security
          VNET_CONFIG=$(az functionapp vnet-integration show \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "vnetResourceId" -o tsv 2>/dev/null || echo "null")

          if [ "$VNET_CONFIG" != "null" ] && [ "$VNET_CONFIG" != "" ]; then
            echo "VNet integration detected, restoring private network access..."
            az functionapp update \
              --resource-group rg-azpolicy-dev-eastus \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --set publicNetworkAccessEnabled=false || echo "Failed to disable public access"
          fi

          echo "Cleanup completed"
  test-deployment:
    runs-on: ubuntu-latest
    needs: deploy
    name: Test Deployed Function
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch') && github.event_name != 'pull_request'

    steps:
      - name: 'Azure Login'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Test Function Endpoints'
        shell: bash
        run: |
          echo "Testing deployed function endpoints..."

          # Get function keys for testing
          FUNCTION_KEY=$(az functionapp keys list \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --resource-group rg-azpolicy-dev-eastus \
            --query "functionKeys.default" -o tsv)

          # Test endpoints using function key
          BASE_URL="https://${{ env.AZURE_FUNCTIONAPP_NAME }}.azurewebsites.net"

          echo "Testing Hello World endpoint..."
          curl -f -s "$BASE_URL/api/hello?code=$FUNCTION_KEY&name=GitHub" || { echo "Hello endpoint test failed"; exit 1; }

          echo "Testing Health endpoint..."
          curl -f -s "$BASE_URL/api/health?code=$FUNCTION_KEY" || { echo "Health endpoint test failed"; exit 1; }

          echo "Testing Info endpoint..."
          curl -f -s "$BASE_URL/api/info?code=$FUNCTION_KEY" || { echo "Info endpoint test failed"; exit 1; }

          echo "‚úÖ Function endpoint tests completed"
