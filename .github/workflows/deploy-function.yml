name: Deploy Azure Function

on:
  push:
    branches: [master]
    paths:
      - 'functions/basic/**'
      - '.github/workflows/deploy-function.yml'
  pull_request:
    branches: [master]
    paths:
      - 'functions/basic/**'
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_NAME: func-azpolicy-dev-001
  AZURE_FUNCTIONAPP_PACKAGE_PATH: './functions/basic'
  PYTHON_VERSION: '3.13'

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    name: Build and Test Function

    steps:
      - name: 'Checkout GitHub Action'
        uses: actions/checkout@v5

      - name: Setup Python ${{ env.PYTHON_VERSION }} Environment
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: 'Resolve Project Dependencies Using Pip'
        shell: bash
        run: |
          pushd '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          python -m pip install --upgrade pip
          pip install -r requirements.txt --target=".python_packages/lib/site-packages"
          popd

      - name: 'Run Unit Tests'
        shell: bash
        run: |
          pushd '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          python -m pip install pytest pytest-cov
          # Install the function requirements for testing
          python -m pip install -r requirements.txt
          python -m pytest tests/ -v --cov=. --cov-report=xml
          popd

      - name: 'Create Function Package'
        shell: bash
        run: |
          pushd '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          # Remove test files and cache from package
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
          find . -name "*.pyc" -delete 2>/dev/null || true
          find . -name ".coverage" -delete 2>/dev/null || true
          find . -name "coverage.xml" -delete 2>/dev/null || true
          popd

      - name: 'Upload Function Package'
        uses: actions/upload-artifact@v4
        with:
          name: function-package
          path: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          retention-days: 1

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-test
    name: Deploy to Azure Function App
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch') && github.event_name != 'pull_request'

    steps:
      - name: 'Download Function Package'
        uses: actions/download-artifact@v5
        with:
          name: function-package
          path: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}

      - name: 'Azure Login'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Verify Infrastructure'
        shell: bash
        run: |
          echo "=== Infrastructure Verification ==="

          # Check if resource group exists
          echo "üìã Checking resource group..."
          RG_EXISTS=$(az group exists --name rg-azpolicy-dev-eastus)
          echo "Resource Group exists: $RG_EXISTS"

          if [ "$RG_EXISTS" = "false" ]; then
            echo "‚ùå ERROR: Resource group 'rg-azpolicy-dev-eastus' does not exist!"
            exit 1
          fi

          # Check Function App existence and status
          echo "üì± Checking Function App..."
          FUNC_APP_STATE=$(az functionapp show \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "{name:name, state:state, publicNetworkAccess:publicNetworkAccessEnabled, httpsOnly:httpsOnly}" \
            -o json 2>/dev/null || echo "null")

          if [ "$FUNC_APP_STATE" = "null" ]; then
            echo "‚ùå ERROR: Function App '${{ env.AZURE_FUNCTIONAPP_NAME }}' does not exist!"
            exit 1
          fi

          echo "Function App Details:"
          echo "$FUNC_APP_STATE" | jq .

          # Check Storage Account
          echo "üíæ Checking Storage Account..."
          STORAGE_STATE=$(az storage account show \
            --resource-group rg-azpolicy-dev-eastus \
            --name stfuncazpolicydev001 \
            --query "{name:name, provisioningState:provisioningState, publicNetworkAccess:publicNetworkAccess}" \
            -o json 2>/dev/null || echo "null")

          if [ "$STORAGE_STATE" = "null" ]; then
            echo "‚ùå ERROR: Storage Account 'stfuncazpolicydev001' does not exist!"
            exit 1
          fi

          echo "Storage Account Details:"
          echo "$STORAGE_STATE" | jq .

          # Check VNet Integration
          echo "üåê Checking VNet Integration..."
          VNET_CONFIG=$(az functionapp vnet-integration show \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "{vnetResourceId:vnetResourceId, subnetResourceId:subnetResourceId}" \
            -o json 2>/dev/null || echo "null")

          echo "VNet Integration:"
          if [ "$VNET_CONFIG" = "null" ]; then
            echo "No VNet integration configured"
          else
            echo "$VNET_CONFIG" | jq .
          fi

          # Check current access restrictions
          echo "üîí Checking Access Restrictions..."
          ACCESS_RESTRICTIONS=$(az functionapp config access-restriction show \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "ipSecurityRestrictions[?action=='Allow']" \
            -o json 2>/dev/null || echo "[]")

          echo "Current Access Restrictions:"
          echo "$ACCESS_RESTRICTIONS" | jq .

          # Check SCM site accessibility
          echo "üîß Testing SCM Site Connectivity..."
          SCM_URL="https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$SCM_URL" --max-time 10 || echo "000")
          echo "SCM Site HTTP Status: $HTTP_STATUS"

          if [ "$HTTP_STATUS" = "000" ]; then
            echo "‚ùå CRITICAL: Cannot reach SCM site - likely network restrictions"
            echo "::error::SCM site is unreachable. Deployment will fail due to network restrictions."
            echo "This indicates VNet integration is blocking external access to the Function App."
            echo "Consider using Azure DevOps self-hosted agents within your VNet for deployment."
            exit 1
          elif [ "$HTTP_STATUS" = "403" ]; then
            echo "‚ö†Ô∏è  INFO: SCM site blocked (403) - access restrictions detected"
            echo "::warning::SCM site returns 403 Forbidden due to access restrictions."
            echo "The Function App has VNet integration and private network access configured."
            echo "This is a security configuration that blocks external access to deployment endpoints."
            echo "The deployment will attempt to create temporary access rules to proceed..."
          elif [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "401" ]; then
            echo "‚úÖ SCM site is reachable - deployment should succeed"
          else
            echo "‚ö†Ô∏è WARNING: SCM site returned unexpected status: $HTTP_STATUS"
            echo "::warning::Unexpected SCM response. Deployment may fail."
          fi

          echo "=== Infrastructure Verification Complete ==="
          echo ""
          echo "üéØ SUMMARY:"
          echo "‚úÖ Resource Group: EXISTS"
          echo "‚úÖ Function App: DEPLOYED"
          echo "‚úÖ Storage Account: AVAILABLE"
          if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "401" ]; then
            echo "‚úÖ SCM Connectivity: ACCESSIBLE"
            echo "üöÄ Ready for deployment!"
          elif [ "$HTTP_STATUS" = "403" ]; then
            echo "‚ö†Ô∏è  SCM Connectivity: RESTRICTED (will configure access rules)"
            echo "üîê Will proceed with temporary access rule configuration..."
          else
            echo "‚ùì SCM Connectivity: UNKNOWN ($HTTP_STATUS)"
            echo "ü§û Proceeding with deployment attempt..."
          fi

      - name: 'Get Runner IP and Configure Access'
        shell: bash
        run: |
          # Get the current runner's public IP
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "üåê Runner IP: $RUNNER_IP"
          echo "::notice::GitHub Actions runner IP: $RUNNER_IP"

          # Check if Function App has public network access disabled
          PUBLIC_ACCESS=$(az functionapp show \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "publicNetworkAccess" -o tsv 2>/dev/null || echo "")

          echo "üì° Public Network Access Enabled: '$PUBLIC_ACCESS'"

          # Handle the case where the property might be null, empty, or not set
          if [ -z "$PUBLIC_ACCESS" ] || [ "$PUBLIC_ACCESS" = "null" ]; then
            echo "‚ö†Ô∏è  Public network access property is not set or null - assuming default (enabled)"
            PUBLIC_ACCESS="Enabled"
          fi

          # Store original public access setting
          echo "ORIGINAL_PUBLIC_ACCESS=$PUBLIC_ACCESS" >> "$GITHUB_ENV"

          if [ "$PUBLIC_ACCESS" = "Disabled" ]; then
            echo "‚ö†Ô∏è  Function App has public network access disabled"
            echo "::warning::Function App has public network access disabled. Temporarily enabling for deployment."

            # Try to temporarily enable public access for deployment
            echo "üîì Temporarily enabling public network access for deployment..."
            az functionapp update \
              --resource-group rg-azpolicy-dev-eastus \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --set publicNetworkAccess=Enabled

            # Wait for the setting to take effect
            echo "‚è≥ Waiting for public access change to propagate..."
            sleep 30
          fi

          # Remove any existing GitHub Actions access restriction rules first (cleanup from previous runs)
          echo "üßπ Cleaning up any existing GitHub Actions access rules..."

          # Get access restriction rules in a more resilient way
          EXISTING_RULES=$(az functionapp config access-restriction list \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "[?contains(name, 'GitHubActions')].name" -o tsv 2>/dev/null || echo "")

          if [ -n "$EXISTING_RULES" ]; then
            echo "$EXISTING_RULES" | while read -r rule_name; do
              if [ -n "$rule_name" ]; then
                echo "  Removing existing rule: $rule_name"
                az functionapp config access-restriction remove \
                  --resource-group rg-azpolicy-dev-eastus \
                  --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
                  --rule-name "$rule_name" || true
              fi
            done
          else
            echo "  No existing GitHub Actions rules found"
          fi

          # Wait for cleanup to complete
          sleep 15

          # Create a unique rule name for this deployment
          RULE_NAME="GitHubActions-Deploy-$(date +%s)"
          echo "GITHUB_ACTIONS_RULE_NAME=$RULE_NAME" >> "$GITHUB_ENV"

          # Add GitHub Actions IP to Function App access restrictions with higher priority
          echo "üîí Adding runner IP to Function App access restrictions..."
          echo "  Rule name: $RULE_NAME"
          echo "  IP address: $RUNNER_IP/32"

          az functionapp config access-restriction add \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --rule-name "$RULE_NAME" \
            --action Allow \
            --ip-address "$RUNNER_IP/32" \
            --priority 50

          # Also add the rule for SCM site specifically
          echo "üîê Adding runner IP to SCM site access restrictions..."
          az functionapp config access-restriction add \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --rule-name "$RULE_NAME-SCM" \
            --action Allow \
            --ip-address "$RUNNER_IP/32" \
            --priority 50 \
            --scm-site || echo "SCM rule may already exist or not be needed"

          echo "‚è≥ Waiting for access rules to take effect..."
          sleep 45

          # Test connectivity to SCM endpoint after configuration
          echo "üß™ Testing SCM connectivity after configuration..."
          SCM_URL="https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net"
          MAX_RETRIES=3
          for i in $(seq 1 $MAX_RETRIES); do
            echo "  Attempt $i/$MAX_RETRIES..."
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$SCM_URL" --max-time 20 || echo "000")
            echo "  SCM Site HTTP Status: $HTTP_STATUS"

            if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "401" ] || [ "$HTTP_STATUS" = "302" ]; then
              echo "‚úÖ SCM site is now accessible - ready for deployment!"
              break
            elif [ "$HTTP_STATUS" = "403" ]; then
              echo "‚ö†Ô∏è  Still getting 403 - waiting longer for access rules to propagate..."
              if [ "$i" -lt "$MAX_RETRIES" ]; then
                sleep 30
              fi
            else
              echo "‚ö†Ô∏è  Unexpected status $HTTP_STATUS - retrying..."
              if [ "$i" -lt "$MAX_RETRIES" ]; then
                sleep 15
              fi
            fi
          done

          if [ "$HTTP_STATUS" != "200" ] && [ "$HTTP_STATUS" != "401" ] && [ "$HTTP_STATUS" != "302" ]; then
            echo "‚ùå CRITICAL: SCM site still not accessible after configuration"
            echo "::error::Unable to access SCM endpoint after configuring access rules. Status: $HTTP_STATUS"
            exit 1
          fi

      - name: 'Deploy to Azure Functions'
        shell: bash
        run: |
          echo "Deploying function package using Azure CLI..."
          cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}

          # Create zip package
          zip -r ../function-deploy.zip . -x "tests/*" "*/__pycache__/*" "*.pyc" ".coverage" "coverage.xml"

          # Deploy using Azure CLI
          az functionapp deployment source config-zip \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --src ../function-deploy.zip \
            --build-remote true

          echo "Deployment completed"

      - name: 'Verify Deployment'
        shell: bash
        run: |
          echo "Waiting for deployment to complete and verifying deployment..."
          MAX_ATTEMPTS=10
          SLEEP_SECONDS=10
          ATTEMPT=1
          SUCCESS=0

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT: Checking function status..."
            # Try to show the HealthCheck function using Azure CLI
            FUNC_NAME=$(az functionapp function show \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --resource-group rg-azpolicy-dev-eastus \
              --function-name HealthCheck \
              --query "name" -o tsv 2>/dev/null)
            if [ "$FUNC_NAME" = "HealthCheck" ]; then
              echo "‚úÖ Function deployment verified successfully"
              SUCCESS=1
              break
            else
              echo "Function not available yet. Waiting $SLEEP_SECONDS seconds before retrying..."
              sleep $SLEEP_SECONDS
              ATTEMPT=$((ATTEMPT+1))
            fi
          done

          if [ $SUCCESS -ne 1 ]; then
            echo "‚ùå Function deployment verification failed after $MAX_ATTEMPTS attempts."
            exit 1
          fi

      - name: 'Cleanup Access Rules'
        if: always()
        shell: bash
        run: |
          echo "üßπ Cleaning up temporary GitHub Actions access rules..."

          # Remove the specific rule created during this deployment
          if [ -n "${GITHUB_ACTIONS_RULE_NAME:-}" ]; then
            echo "  Removing deployment rule: ${GITHUB_ACTIONS_RULE_NAME}"
            az functionapp config access-restriction remove \
              --resource-group rg-azpolicy-dev-eastus \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --rule-name "${GITHUB_ACTIONS_RULE_NAME}" || true

            echo "  Removing SCM deployment rule: ${GITHUB_ACTIONS_RULE_NAME}-SCM"
            az functionapp config access-restriction remove \
              --resource-group rg-azpolicy-dev-eastus \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --rule-name "${GITHUB_ACTIONS_RULE_NAME}-SCM" \
              --scm-site || true
          fi          # Remove any remaining GitHub Actions rules (cleanup from failed runs)
          echo "  Cleaning up any remaining GitHub Actions access rules..."

          # Get remaining access restriction rules in a more resilient way
          REMAINING_RULES=$(az functionapp config access-restriction list \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "[?contains(name, 'GitHubActions')].name" -o tsv 2>/dev/null || echo "")

          if [ -n "$REMAINING_RULES" ]; then
            echo "$REMAINING_RULES" | while read -r rule_name; do
              if [ -n "$rule_name" ]; then
                echo "    Removing rule: $rule_name"
                az functionapp config access-restriction remove \
                  --resource-group rg-azpolicy-dev-eastus \
                  --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
                  --rule-name "$rule_name" || true
              fi
            done
          else
            echo "    No remaining GitHub Actions rules found"
          fi

          # Restore original public network access setting
          echo "üîí Restoring original public network access setting..."
          if [ "${ORIGINAL_PUBLIC_ACCESS:-}" = "Disabled" ]; then
            echo "  Restoring public network access to: disabled"
            az functionapp update \
              --resource-group rg-azpolicy-dev-eastus \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --set publicNetworkAccess=Disabled || echo "Failed to restore public access setting"
          else
            echo "  Original setting was enabled, no restoration needed"
          fi

          # If VNet integration exists, ensure private network access for security
          VNET_CONFIG=$(az functionapp vnet-integration show \
            --resource-group rg-azpolicy-dev-eastus \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "vnetResourceId" -o tsv 2>/dev/null || echo "null")

          if [ "$VNET_CONFIG" != "null" ] && [ "$VNET_CONFIG" != "" ]; then
            echo "üîê VNet integration detected, ensuring private network access..."
            az functionapp update \
              --resource-group rg-azpolicy-dev-eastus \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --set publicNetworkAccess=Disabled || echo "Failed to secure with private access"
          fi

          echo "‚úÖ Cleanup completed"
  test-deployment:
    runs-on: ubuntu-latest
    needs: deploy
    name: Test Deployed Function
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch') && github.event_name != 'pull_request'

    steps:
      - name: 'Azure Login'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Test Function Endpoints'
        shell: bash
        run: |
          echo "Testing deployed function endpoints..."

          # Get function keys for testing
          FUNCTION_KEY=$(az functionapp keys list \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --resource-group rg-azpolicy-dev-eastus \
            --query "functionKeys.default" -o tsv)

          # Test endpoints using function key
          BASE_URL="https://${{ env.AZURE_FUNCTIONAPP_NAME }}.azurewebsites.net"

          echo "Testing Hello World endpoint..."
          curl -f -s "$BASE_URL/api/hello?code=$FUNCTION_KEY&name=GitHub" || { echo "Hello endpoint test failed"; exit 1; }

          echo "Testing Health endpoint..."
          curl -f -s "$BASE_URL/api/health?code=$FUNCTION_KEY" || { echo "Health endpoint test failed"; exit 1; }

          echo "Testing Info endpoint..."
          curl -f -s "$BASE_URL/api/info?code=$FUNCTION_KEY" || { echo "Info endpoint test failed"; exit 1; }

          echo "‚úÖ Function endpoint tests completed"
